From 93937bed2965b3a7b60f92a357e0afa195969fe7 Mon Sep 17 00:00:00 2001
From: Victor Rodriguez <victor.rodriguez.bahena@intel.com>
Date: Mon, 7 Aug 2017 05:05:23 +0000
Subject: [PATCH] Rebase of parse.y: utf-8 codepoints

    * parse.y (parser_tokadd_utf8): skip spaces in the current line,
      without advancing the line, to get rid of dangling pointer.
      [ruby-core:82029] [Bug #13742]

    git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/trunk@59344 b2dd03c8-39d4-4d8f-98ff-823fe69b080e
    Author: nobu <nobu@b2dd03c8-39d4-4d8f-98ff-823fe69b080e>

Signed-off-by: Victor Rodriguez <victor.rodriguez.bahena@intel.com>
---
 parse.y                 | 69 ++++++++++++++++++++++++++++++++-----------------
 test/ruby/test_parse.rb | 28 ++++++++++----------
 2 files changed, 59 insertions(+), 38 deletions(-)

diff --git a/parse.y b/parse.y
index 89d80b9..3bea435 100644
--- a/parse.y
+++ b/parse.y
@@ -259,6 +259,7 @@ struct parser_params {
 	const char *pbeg;
 	const char *pcur;
 	const char *pend;
+    const char *ptok;
 	long gets_ptr;
 	enum lex_state_e state;
 	int paren_nest;
@@ -317,7 +318,6 @@ struct parser_params {
 #else
     /* Ripper only */
 
-    const char *tokp;
     VALUE delayed;
     int delayed_line;
     int delayed_col;
@@ -342,6 +342,7 @@ struct parser_params {
 
 static int parser_yyerror(struct parser_params*, const char*);
 #define yyerror(msg) parser_yyerror(parser, (msg))
+#define token_flush(p) ((p)->lex.ptok = (p)->lex.pcur)
 
 #define lex_strterm		(parser->lex.strterm)
 #define lex_state		(parser->lex.state)
@@ -387,6 +388,7 @@ static int parser_yyerror(struct parser_params*, const char*);
 #define ruby_debug_lines	(parser->debug_lines)
 #define ruby_coverage		(parser->coverage)
 #endif
+#define tokp			lex.ptok
 
 #define CALL_Q_P(q) ((q) == tANDDOT)
 #define NODE_CALL_Q(q) (CALL_Q_P(q) ? NODE_QCALL : NODE_CALL)
@@ -5260,7 +5262,7 @@ parser_yyerror(struct parser_params *parser, const char *msg)
     long len;
     int i;
 
-    p = lex_p;
+    p = parser->tokp;
     lim = p - lex_pbeg > max_line_margin ? p - max_line_margin : lex_pbeg;
     while (lim < p) {
 	if (*(p-1) == '\n') break;
@@ -5765,6 +5767,7 @@ parser_tokadd_codepoint(struct parser_params *parser, rb_encoding **encp,
 {
     size_t numlen;
     int codepoint = scan_hex(lex_p, wide ? 6 : 4, &numlen);
+    lex_p += numlen;
     if (wide ? (numlen == 0) : (numlen < 4))  {
 	yyerror("invalid Unicode escape");
 	return FALSE;
@@ -5777,12 +5780,20 @@ parser_tokadd_codepoint(struct parser_params *parser, rb_encoding **encp,
 	yyerror("invalid Unicode codepoint");
 	return FALSE;
     }
-    lex_p += numlen;
     if (regexp_literal) {
 	tokcopy((int)numlen);
     }
     else if (codepoint >= 0x80) {
-	*encp = rb_utf8_encoding();
+	rb_encoding *utf8 = rb_utf8_encoding();
+	if (*encp && utf8 != *encp) {
+		static const char mixed_utf8[] = "UTF-8 mixed within %s source";
+		size_t len = sizeof(mixed_utf8) - 2 + strlen(rb_enc_name(*encp));
+		char *mesg = alloca(len);
+		snprintf(mesg, len, mixed_utf8, rb_enc_name(*encp));
+		yyerror(mesg);
+		return TRUE;
+	}
+	*encp = utf8;
 	tokaddmbc(codepoint, *encp);
     }
     else {
@@ -5809,19 +5820,23 @@ parser_tokadd_utf8(struct parser_params *parser, rb_encoding **encp,
 
     if (peek(open_brace)) {  /* handle \u{...} form */
 	int c, last = nextc();
-	do c = nextc(); while (ISSPACE(c));
-	pushback(c);
+	if (lex_p >= lex_pend) goto unterminated;
+	while (ISSPACE(c = *lex_p) && ++lex_p < lex_pend);
 	while (!string_literal || c != close_brace) {
 	    if (regexp_literal) tokadd(last);
 	    if (!parser_tokadd_codepoint(parser, encp, regexp_literal, TRUE)) {
 		return 0;
 	    }
-	    while (ISSPACE(c = nextc())) last = c;
-	    pushback(c);
+		while (ISSPACE(c = *lex_p)) {
+			if (++lex_p >= lex_pend) goto unterminated;
+			last = c;
+		}
 	    if (!string_literal) break;
 	}
 
 	if (c != close_brace) {
+		unterminated:
+		parser->tokp = lex_p;
 	    yyerror("unterminated Unicode escape");
 	    return 0;
 	}
@@ -6116,8 +6131,7 @@ parser_tokadd_string(struct parser_params *parser,
 		     rb_encoding **encp)
 {
     int c;
-    int has_nonascii = 0;
-    rb_encoding *enc = *encp;
+	rb_encoding *enc = 0;
     char *errbuf = 0;
     static const char mixed_msg[] = "%s mixed within %s source";
 
@@ -6161,7 +6175,10 @@ parser_tokadd_string(struct parser_params *parser,
 	    }
 	}
 	else if (c == '\\') {
-	    const char *beg = lex_p - 1;
+        const char *beg = lex_p - 1;
+#ifndef RIPPER
+        parser->tokp = lex_p - 1;
+#endif
 	    c = nextc();
 	    switch (c) {
 	      case '\n':
@@ -6179,11 +6196,10 @@ parser_tokadd_string(struct parser_params *parser,
 		    tokadd('\\');
 		    break;
 		}
-		parser_tokadd_utf8(parser, &enc, 1,
-				   func & STR_FUNC_SYMBOL,
-				   func & STR_FUNC_REGEXP);
-		if (has_nonascii && enc != *encp) {
-		    mixed_escape(beg, enc, *encp);
+        if (!parser_tokadd_utf8(parser, &enc, term,
+                                func & STR_FUNC_SYMBOL,
+                                func & STR_FUNC_REGEXP)) {
+            return -1;
 		}
 		continue;
 
@@ -6201,8 +6217,8 @@ parser_tokadd_string(struct parser_params *parser,
 		    pushback(c);
 		    if ((c = tokadd_escape(&enc)) < 0)
 			return -1;
-		    if (has_nonascii && enc != *encp) {
-			mixed_escape(beg, enc, *encp);
+                if (enc && enc != *encp) {
+                    mixed_escape(parser->tokp+2, enc, *encp);
 		    }
 		    continue;
 		}
@@ -6223,8 +6239,10 @@ parser_tokadd_string(struct parser_params *parser,
 	}
 	else if (!parser_isascii()) {
 	  non_ascii:
-	    has_nonascii = 1;
-	    if (enc != *encp) {
+		if (!enc) {
+			enc = *encp;
+		}
+		else if (enc != *encp) {
 		mixed_error(enc, *encp);
 		continue;
 	    }
@@ -6236,15 +6254,17 @@ parser_tokadd_string(struct parser_params *parser,
 	    break;
 	}
         if (c & 0x80) {
-	    has_nonascii = 1;
-	    if (enc != *encp) {
+		if (!enc) {
+			enc = *encp;
+		}
+		else if (enc != *encp) {
 		mixed_error(enc, *encp);
 		continue;
 	    }
         }
 	tokadd(c);
     }
-    *encp = enc;
+    if (enc) *encp = enc;
     return c;
 }
 
@@ -7562,7 +7582,8 @@ parse_qmark(struct parser_params *parser, int space_seen)
     else if (c == '\\') {
 	if (peek('u')) {
 	    nextc();
-	    if (!parser_tokadd_utf8(parser, &enc, 0, 0, 0))
+		enc = rb_utf8_encoding();
+		if (!parser_tokadd_utf8(parser, &enc, -1, 0, 0))
 		return 0;
 	}
 	else if (!lex_eol_p() && !(c = *lex_p, ISASCII(c))) {
diff --git a/test/ruby/test_parse.rb b/test/ruby/test_parse.rb
index b4a63e3..a285be6 100644
--- a/test/ruby/test_parse.rb
+++ b/test/ruby/test_parse.rb
@@ -484,24 +484,24 @@ def test_carrige_return
   end
 
   def test_string
-    assert_raise(SyntaxError) do
-      eval '"\xg1"'
-    end
+     mesg = 'from the backslash through the invalid char'
+     e = assert_syntax_error('"\xg1"', /hex escape/)
+     assert_equal('   ^', e.message.lines.last, mesg)
 
-    assert_raise(SyntaxError) do
-      eval '"\u{1234"'
-    end
+     e = assert_syntax_error('"\u{1234"', 'Unicode escape')
+     assert_match(' ^~~~~~~', e.message.lines.last, mesg)
 
-    assert_raise(SyntaxError) do
-      eval '"\M1"'
-    end
+     e = assert_syntax_error('"\M1"', /escape character syntax/)
+     assert_equal(' ^~~', e.message.lines.last, mesg)
 
-    assert_raise(SyntaxError) do
-      eval '"\C1"'
-    end
+     e = assert_syntax_error('"\C1"', /escape character syntax/)
+     assert_equal(' ^~~', e.message.lines.last, mesg)
+
+     src = '"\xD0\u{90'"\n""000000000000000000000000"
+     assert_syntax_error(src, /:#{__LINE__}: unterminated/o)
 
-    assert_equal("\x81", eval('"\C-\M-a"'))
-    assert_equal("\177", eval('"\c?"'))
+     assert_equal("\x81", eval('"\C-\M-a"'))
+     assert_equal("\177", eval('"\c?"'))
   end
 
   def test_question
-- 
2.13.4

